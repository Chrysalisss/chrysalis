/**
 * Chrysalis v0.9.0-β
 * Casper Søkol, 2018
 * Distributed under the MIT license
 */

const createElement=(t,e,...n)=>{null===e&&(e={});return{type:t,props:e,children:n}},render$1=(t=null,e=null)=>{const n=e?t=>e.appendChild(t):t=>t;if("string"==typeof t||"number"==typeof t)return n(document.createTextNode(t));if("boolean"==typeof t||null===t)return n(document.createTextNode(""));if("object"==typeof t&&"function"==typeof t.type)return Component.render(t,e);if("object"==typeof t&&"string"==typeof t.type){const e=n(document.createElement(t.type));for(let n of[].concat(...t.children))render$1(n,e);for(let n in t.props)setAttribute(e,n,t.props[n]);return e}},setAttribute$1=(t,e,n)=>{if("function"==typeof n&&e.startsWith("on")){const o=e.slice(2).toLowerCase();t.__gooactHandlers=t.__gooactHandlers||{},t.removeEventListener(o,t.__gooactHandlers[o]),t.__gooactHandlers[o]=n,t.addEventListener(o,t.__gooactHandlers[o])}"checked"!=e&&"value"!=e&&"className"!=e||(t[e]=n);"style"==e&&"object"==typeof n&&Object.assign(t.style,n);"ref"==e&&"function"==typeof n&&n(t);"key"==e&&(t.__gooactKey=n);"object"!=typeof n&&"function"!=typeof n&&t.setAttribute(e,n)},patch$1=(t,e,n=t.parentNode)=>{let o=parent?e=>parent.replaceChild(e,t)&&e:t=>t;if("object"==typeof e&&"function"==typeof e.type)return Component.patch(t,e,parent);if("object"!=typeof e&&t instanceof Text)return t.textContent!=e?o(render(e,parent)):t;if("object"==typeof e&&t instanceof Text)return o(render(e,parent));if("object"==typeof e&&t.nodeName!=e.type.toUpperCase())return o(render(e,parent));if("object"==typeof e&&t.nodeName==e.type.toUpperCase()){let n={},o=document.activeElement;[].concat(...t.childNodes).map((t,e)=>{let o=t.__gooactKey||`__index_${e}`;n[o]=t}),[].concat(...e.children).map((e,o)=>{let r=e.props&&e.props.key||`__index_${o}`;t.appendChild(n[r]?patch$1(n[r],e):render(e,t));delete n[r]});for(let t in n){let e=n[t].__gooactInstance;e&&e.componentWillUnmount(),n[t].remove()}for(let e of t.attributes)t.removeAttribute(e.name);for(let n in e.props)setAttribute(t,n,e.props[n]);return o.focus(),t}};class Component$1{constructor(t){this.props=t||{},this.state=null}static render(t,e=null){let n=Object.assign({},t.props,{children:t.children});if(Component$1.isPrototypeOf(t.type)){const o=new t.type(n);return o.componentWillMount(),o.base=render(o.render(),e),o.base.__gooactInstance=o,o.base.__gooactKey=t.props.key,o.componentDidMount(),o.base}return render(t.type(n),e)}static patch(t,e,n=t.parentNode){let o=Object.assign({},e.props,{children:e.children});if(t.__gooactInstance&&t.__gooactInstance.constructor==e.type)return t.__gooactInstance.componentWillReceiveProps(o),t.__gooactInstance.props=o,patch(t,t.__gooactInstance.render(),n);if(Component$1.isPrototypeOf(e.type)){let o=Component$1.render(e,n);return n?n.replaceChild(o,t)&&o:o}return Component$1.isPrototypeOf(e.type)?void 0:patch(t,e.type(o),n)}setState(t){if(this.base&&this.shouldComponentUpdate(this.props,t)){const e=this.state;this.componentWillUpdate(this.props,t),this.state=t,patch(this.base,this.render()),this.componentDidUpdate(this.props,e)}else this.state=t}shouldComponentUpdate(t,e){return t!=this.props||e!=this.state}componentWillReceiveProps(t){}componentWillUpdate(t,e){}componentDidUpdate(t,e){}componentWillMount(){}componentDidMount(){}componentWillUnmount(){}}var Chrysalis={createElement:createElement,render:render$1,setAttribute:setAttribute$1,patch:patch$1,Component:Component$1};export default Chrysalis;
