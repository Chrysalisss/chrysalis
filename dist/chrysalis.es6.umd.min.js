/**
 * Chrysalis v0.9.0-β
 * Casper Søkol, 2018
 * Distributed under the MIT license
 */

!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.Chrysalis=e()}(this,function(){"use strict";const t=(e=null,n=null)=>{const o=n?t=>n.appendChild(t):t=>t;if("string"==typeof e||"number"==typeof e)return o(document.createTextNode(e));if("boolean"==typeof e||null===e)return o(document.createTextNode(""));if("object"==typeof e&&"function"==typeof e.type)return Component.render(e,n);if("object"==typeof e&&"string"==typeof e.type){const n=o(document.createElement(e.type));for(const o of[].concat(...e.children))t(o,n);for(const t in e.props)setAttribute(n,t,e.props[t]);return n}},e=(t,e,n)=>{if("function"==typeof n&&e.startsWith("on")){const o=e.slice(2).toLowerCase();t.__gooactHandlers=t.__gooactHandlers||{},t.removeEventListener(o,t.__gooactHandlers[o]),t.__gooactHandlers[o]=n,t.addEventListener(o,t.__gooactHandlers[o])}"checked"!=e&&"value"!=e&&"className"!=e||(t[e]=n);"style"==e&&"object"==typeof n&&Object.assign(t.style,n);"ref"==e&&"function"==typeof n&&n(t);"key"==e&&(t.__gooactKey=n);"object"!=typeof n&&"function"!=typeof n&&t.setAttribute(e,n)},n=(t,e,o=t.parentNode)=>{const r=parent?e=>parent.replaceChild(e,t)&&e:t=>t;if("object"==typeof e&&"function"==typeof e.type)return Component.patch(t,e,parent);if("object"!=typeof e&&t instanceof Text)return t.textContent!=e?r(render(e,parent)):t;if("object"==typeof e&&t instanceof Text)return r(render(e,parent));if("object"==typeof e&&t.nodeName!=e.type.toUpperCase())return r(render(e,parent));if("object"==typeof e&&t.nodeName==e.type.toUpperCase()){const o={},r=document.activeElement;[].concat(...t.childNodes).map((t,e)=>{const n=t.__gooactKey||`__index_${e}`;o[n]=t}),[].concat(...e.children).map((e,r)=>{const c=e.props&&e.props.key||`__index_${r}`;t.appendChild(o[c]?n(o[c],e):render(e,t));delete o[c]});for(const t in o){const e=o[t].__gooactInstance;e&&e.componentWillUnmount(),o[t].remove()}for(const e of t.attributes)t.removeAttribute(e.name);for(const n in e.props)setAttribute(t,n,e.props[n]);return r.focus(),t}};class o{constructor(t){this.props=t||{},this.state=null}static render(t,e=null){const n=Object.assign({},t.props,{children:t.children});if(o.isPrototypeOf(t.type)){const o=new t.type(n);return o.componentWillMount(),o.base=render(o.render(),e),o.base.__gooactInstance=o,o.base.__gooactKey=t.props.key,o.componentDidMount(),o.base}return render(t.type(n),e)}static patch(t,e,n=t.parentNode){const r=Object.assign({},e.props,{children:e.children});if(t.__gooactInstance&&t.__gooactInstance.constructor==e.type)return t.__gooactInstance.componentWillReceiveProps(r),t.__gooactInstance.props=r,patch(t,t.__gooactInstance.render(),n);if(o.isPrototypeOf(e.type)){const r=o.render(e,n);return n?n.replaceChild(r,t)&&r:r}return o.isPrototypeOf(e.type)?void 0:patch(t,e.type(r),n)}setState(t){if(this.base&&this.shouldComponentUpdate(this.props,t)){const e=this.state;this.componentWillUpdate(this.props,t),this.state=t,patch(this.base,this.render()),this.componentDidUpdate(this.props,e)}else this.state=t}shouldComponentUpdate(t,e){return t!=this.props||e!=this.state}componentWillReceiveProps(t){}componentWillUpdate(t,e){}componentDidUpdate(t,e){}componentWillMount(){}componentDidMount(){}componentWillUnmount(){}}return{createElement:(t,e,...n)=>{null===e&&(e={});return{type:t,props:e,children:n}},render:t,setAttribute:e,patch:n,Component:o}});
