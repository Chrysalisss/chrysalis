/**
 * Chrysalis v0.9.9-β
 * Casper Søkol, 2018
 * Distributed under the MIT license
 */

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.Chrysalis={})}(this,function(e){function t(e,t,n){"className"===t?e.setAttribute("class",n):"boolean"==typeof n?s(e,t,n):e.setAttribute(t,n)}const n=(e,t)=>{let n=[];let i=arguments.length-2;for(;i-- >0;)n[i]=arguments[i+2];return{nodeName:e,attributes:t||{},children:n}},i=e=>{if("object"!=typeof e)return document.createTextNode(e);const t=document.createElement(e.nodeName);for(let n in e.attributes)t.setAttribute(n,e.attributes[n]);e.children.map(i).forEach(t.appendChild.bind(t));return t},o=(e,t)=>{t.appendChild(i(e))},r=(e,t,n,i=0)=>{if(n)if(t){if(changed(t,n))e.replaceChild(h(t),e.childNodes[i]);else if(t.type){d(e.childNodes[i],t.attributes,n.attributes);const o=t.children.length,c=n.children.length;for(let d=0;d<o||d<c;d++)r(e.childNodes[i],t.children[d],n.children[d],d)}}else e.removeChild(e.childNodes[i]);else e.appendChild(h(t))},d=(e,t,n)=>{const i=Object.assign({},newAttrs,oldAttrs);Object.keys(i).forEach(t=>{c(e,t,newAttrs[t],oldAttrs[t])})},c=(e,n,i,o)=>{i?o&&i===o||t(e,n,i):removeAttributes(e,n,o)},s=(e,t,n)=>{n?(e.setAttribute(t,n),e[t]=!0):e[t]=!1};e.h=n,e.render=o,e.updateElement=r,Object.defineProperty(e,"__esModule",{value:!0})});
