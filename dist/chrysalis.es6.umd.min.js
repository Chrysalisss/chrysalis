/**
 * Chrysalis v0.9.0-β
 * Casper Søkol, 2018
 * Distributed under the MIT license
 */

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.Chrysalis=t()}(this,function(){"use strict";const e=(t=null,n=null)=>{const o=n?e=>n.appendChild(e):e=>e;if("string"==typeof t||"number"==typeof t)return o(document.createTextNode(t));if("boolean"==typeof t||null===t)return o(document.createTextNode(""));if("object"==typeof t&&"function"==typeof t.type)return Component.render(t,n);if("object"==typeof t&&"string"==typeof t.type){const n=o(document.createElement(t.type));for(let o of[].concat(...t.children))e(o,n);for(let e in t.props)setAttribute(n,e,t.props[e]);return n}},t=(e,t,n)=>{if("function"==typeof n&&t.startsWith("on")){const o=t.slice(2).toLowerCase();e.__gooactHandlers=e.__gooactHandlers||{},e.removeEventListener(o,e.__gooactHandlers[o]),e.__gooactHandlers[o]=n,e.addEventListener(o,e.__gooactHandlers[o])}"checked"!=t&&"value"!=t&&"className"!=t||(e[t]=n);"style"==t&&"object"==typeof n&&Object.assign(e.style,n);"ref"==t&&"function"==typeof n&&n(e);"key"==t&&(e.__gooactKey=n);"object"!=typeof n&&"function"!=typeof n&&e.setAttribute(t,n)},n=(e,t,o=e.parentNode)=>{let r=parent?t=>parent.replaceChild(t,e)&&t:e=>e;if("object"==typeof t&&"function"==typeof t.type)return Component.patch(e,t,parent);if("object"!=typeof t&&e instanceof Text)return e.textContent!=t?r(render(t,parent)):e;if("object"==typeof t&&e instanceof Text)return r(render(t,parent));if("object"==typeof t&&e.nodeName!=t.type.toUpperCase())return r(render(t,parent));if("object"==typeof t&&e.nodeName==t.type.toUpperCase()){let o={},r=document.activeElement;[].concat(...e.childNodes).map((e,t)=>{let n=e.__gooactKey||`__index_${t}`;o[n]=e}),[].concat(...t.children).map((t,r)=>{let c=t.props&&t.props.key||`__index_${r}`;e.appendChild(o[c]?n(o[c],t):render(t,e));delete o[c]});for(let e in o){let t=o[e].__gooactInstance;t&&t.componentWillUnmount(),o[e].remove()}for(let t of e.attributes)e.removeAttribute(t.name);for(let n in t.props)setAttribute(e,n,t.props[n]);return r.focus(),e}};class o{constructor(e){this.props=e||{},this.state=null}static render(e,t=null){let n=Object.assign({},e.props,{children:e.children});if(o.isPrototypeOf(e.type)){const o=new e.type(n);return o.componentWillMount(),o.base=render(o.render(),t),o.base.__gooactInstance=o,o.base.__gooactKey=e.props.key,o.componentDidMount(),o.base}return render(e.type(n),t)}static patch(e,t,n=e.parentNode){let r=Object.assign({},t.props,{children:t.children});if(e.__gooactInstance&&e.__gooactInstance.constructor==t.type)return e.__gooactInstance.componentWillReceiveProps(r),e.__gooactInstance.props=r,patch(e,e.__gooactInstance.render(),n);if(o.isPrototypeOf(t.type)){let r=o.render(t,n);return n?n.replaceChild(r,e)&&r:r}return o.isPrototypeOf(t.type)?void 0:patch(e,t.type(r),n)}setState(e){if(this.base&&this.shouldComponentUpdate(this.props,e)){const t=this.state;this.componentWillUpdate(this.props,e),this.state=e,patch(this.base,this.render()),this.componentDidUpdate(this.props,t)}else this.state=e}shouldComponentUpdate(e,t){return e!=this.props||t!=this.state}componentWillReceiveProps(e){}componentWillUpdate(e,t){}componentDidUpdate(e,t){}componentWillMount(){}componentDidMount(){}componentWillUnmount(){}}return{createElement:(e,t,...n)=>{null===t&&(t={});return{type:e,props:t,children:n}},render:e,setAttribute:t,patch:n,Component:o}});
